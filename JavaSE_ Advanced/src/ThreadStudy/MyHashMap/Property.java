package ThreadStudy.MyHashMap;

/**
 * @author MOYU
 * @File JavaSE_Study-ThreadStudy.MyHashMap
 * @Date 2022/6/20 17:05
 **/
public class Property {
    /*
    HashMap线程不安全的（多线程出现问题）
    可以使用Hashtable,但是Hashtable效率低下--因为是悲观锁
    ConcurrentHashMap也是线程安全，并且效率高：
            1.7jdk之前：1.默认创建16长度大小的大数组，加载因子0.75，数组不能扩容
                       2.在每个数组元素创建长度为2的小数组，把小数组地址值赋值给大数组索引为0处，其他索引位置为null
                       3.根据哈希值来计算存入在大数组中的位置：
                              如果为null,按照模板创建小数组，创建完成二次哈希，计算出元素在小数组中应该存入的位置
                              不为null,就会根据地址值找到小数组，二次哈希计算出小数组中的位置，若果需要扩容，则扩容小数组为原来的二倍
                                       如果不用扩容，就会看该位置有没有元素，没有直接存，有就equals比较属性值，一样就不存，不一样就
                                       替代原来的数据，原数据挂在它的下面，即为红黑树结构

            1.8jdk之后：底层是数组，链表，红黑树的结合体，在结合CAS机制
                            链表长度大于等于8就变成红黑树

     */
}
