package ThreadStudy.atomic;

/**
 * @author MOYU
 * @File JavaSE_Study-ThreadStudy.atomic
 * @Date 2022/6/19 20:44
 **/
public class Property {
    /*
    原子性指在一次操作中，要么所有的操作全部得到执行并且不受任何因素干扰而中断，要么所有操作不执行，多个操作是一个不可分割的整体

    volatile只能保证获得数据是最新的，不能保证原子性
    锁可以保证原子性--但是比较慢，因为有锁的获得和释放

    原子类原理：自旋锁+CSA算法---修改时记录旧值，进行对比
              CSA算法：3个操作数（内存值，旧的预期值A,要修改的值B)
                      当旧的预期值A==内存值 此时修改成功，将V改为B
                      当旧的预期值A!=内存值 此时修改失败，不做任何操作
                      并重新获取现在的最新值(重新获取的动作就叫自旋锁)

       悲观锁与乐观锁：
                    悲观：synchronized--认为每次获取数据别人都会修改，所以每次都上锁
                    乐观：CAS算法--假设不会有人修改数据，不上锁，但在修改数据时会检查一下，看是否有人修改过，如果修改过就获取最新值，没修改过则直接修改共享数据
     */
}
